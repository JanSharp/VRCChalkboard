wait
if instantiating a synced object isn't an option
what do i do
20 seconds of load time (for a map with 2000 ItemSyncs in it, 200 different items with an object pool of 10 items each) just because VRChat is a terrible software is unacceptable. Not counting the incredibly long build and play mode times
Like what am I supposed to do
I mean, fun fact, there is still a way to do synced instantiation, it's just that the actually instantiated objects cannot have any synced udon behaviours on them. But we can have a single controller outside of those instantiated objects which then handles all of the syncing
however...
that has a big issue.
The nice thing about having each synced object be, well, its own object that's getting synced is that we only sync a very small amount of data (ignoring the fact that VRChat creates way too big packets). If we just have a single controller, it is impossible to have a dynamic amount of synced variables
so instead we would have to have arrays where on pre serialization it creates a new array with a minimum size required to sync all the data it needs
but another issue is that with just a single object we can no longer transfer ownership. that means each player in the world would need their own controller and every controller in the map would have to communicate ownership of items manually.
Don't get me wrong, so far this is all possible. We'd simply have 80 controllers in the map, and the logic is doable. But is it worth it?
No.
Why?
Because it significantly increases complexity, like probably more than double, which increases the chance of bugs and weird edge cases, not to mention scuff caused by VRChat and Unity. It also increases the amount of data that would need to be synced overall, because we have to sync ids and track stuff ourself. We would also have throttling issues because it's just one single object syncing a lot of data, which VRChat is so kind as to slow down how often that object is allowed to send its data to everyone else. At least according to the docs.

Alright, so we have explored instantiate, which we have learned is impossible to instantiate synced objects with because VRChat does not provide an API to do as such, meaning it is quite literally and simply impossible.
Then we have explored the alternative, still using instantiate, but not instantiating synced objects, since that's all we can do, and then manually syncing their state with a single controller. And because of the reasons mentioned above this is also not an option.

So what are we left with? We are left with the initial approach that I was trying to get away from. spamming a bunch of objects in the scene and disabling them to then manage them with a fixed size object pool.
And just for completeness sake, the reason this approach is bad is... well there are multiple:
it slows down the development process because the map maker has to manually duplicate objects in the scene whenever they make changes to them. Unless they use prefabs, in which case they are limited by what prefabs can do. Which to be fair isn't bad, but overall is still cumbersome.
Then there are build times (with which I mean entering play mode and publishing) which get increased significantly. I'm fairly certain it is because of VRChat doing something stupid with UdonBehaviours, which leads me to the next point.
It increases map load times significantly. This depends on what kind of object you are trying to "pool"/"instantiate", however to give Unity some credit, having multiple of the same GameObject ultimately isn't that bad both for load times or render times, because of batching and instanced rendering. And each of those objects share the same meshes and materials. VRChat however managed to somehow take 10ms per ItemSync UdonBehaviour. That's 10 seconds for 1000 of them, regardless of active or inactive. Said UdonBehaviour does not have a Start event btw. With one it takes around 12s and with a slightly more complex one it takes 14s. My guess is that this depends on the complexity of the UdonBehaviour. I already know just how terribly un-optimized UdonBehaviours are, but I'll be honest this is beyond my already low expectations. Without any of the debug stuff (which is preprocessed out) the script is around 500 lines, which for a program is tiny. 10ms to initialize a 500 lines script... Like it's hard to put into words just how terrible that is. I know I'm borderline ranting at this point, but I'm just trying to show why I wanted to avoid this at all cost; Why I investigated the other approaches, which ended up being impossible or not usable. So just to finish my point, 10ms is an eternity for a computer. Like a video game can perform an entire game update tick and render one whole frame in 16ms if it's running at 60 fps, for 144 fps it's 7ms. And VRChat takes 10ms to initialize 1 single 500 line UdonBehaviour script instance.

Alright, with that cleared up, I hope you now understand where I'm coming from and why I really want a different solution. But there isn't one. At least not one I'm aware of.

Ok wait. There is another idea. We reuse the actual ItemSync scripts. That way we don't need 2000 of them, only 160. That's a huge improvement, even if I'm not happy with it.
The we can actually still use instantiate for the actual items but then reuse ItemSync scripts whenever and item is held. That means we need a local manager that keeps track of all items in the world and keeps an id for them, where said id is the same for every client. Each instantiated item would have a tiny script to get pickup and drop events and to track its id.
When picking up an item that script would inform the manager that this id got picked up and the manager then assigns a free ItemSync script to that id, setting a few references in the ItemSync script to make it track the correct object in the world.
There are still some issues with this though. For example when 2 players pick up different items at the same time, locally they'd end up using the same ItemSync instance to track their item, but as soon as a network tick happens one would override the other, which means we need some logic in the ItemSync script to detect it being used for multiple items and then inform the manager to allocate a different ItemSync instance. The collision already gets resolved by VRChat because only one player can be the owner of an object, so whoever ends up being the owner wins and the other player has to use a different ItemSync instance. However to reduce the chance of collisions the manager should probably choose one at random instead of going in sequence.
The next challenge are late joiners. Late joiners need to be informed about every instantiated item and its position and rotation in the world. The parent for all items is probably going to be the same, at least for now.
I think the only way to handle late joiners is to have an object that has all items in an array and all of their ids in an array. Although the ids are ultimately going to be the item index so that's not needed. Then on pre serialization it would populate an array of positions, rotations and of the type of item each one is, since for the joining client they must all be instantiated. However there also needs to be a way to sync the currently held state for late joiners. I believe the ItemSync scripts would already handle that, except that the data could arrive out of order, meaning an ItemSync might want to take control of an item for the new client where said item doesn't even exist yet. That means both the manager and the ItemSync script must both have special handling for that case.
While this approach introduces several new edge cases and complexity it does provide several benefits:
It decreases development time for the map maker. They no longer have to duplicate objects and make object pools. They also get to enter play mode faster because there are fewer UdonBehaviours for VRChat to initialize, and just less objects in the world in general. And they also get to publish their world faster for the same reason, allowing for faster multiplayer testing.
It decreases map load times, at least in theory. There would be a fixed amount of scripts for ItemSyncing in the world, regardless of how many different items you might have, which means the load times get better compared to the initial approach the more different items you have (for example with 16 different items with an object pool of 10 items each the systems would be about equal. Any more items than that and this approach would be faster. Again: In theory). However if the player is joining a world that was already active for a while and people spawned and de-spawned several items then the new client would have to instantiate all of those. I have no idea how expensive that is.
It removes the artificial limit on items. You can spawn as many of the same item and as many of different items as you want. The only limit is practicality.
Beyond that I'm unsure if de-spawning an item should ever delete the object instead of just deactivating it for potential later use. Honestly the proper way to handle that would be to have a timer for deactivated objects to then delete them when they expire, basically. However for the first implementation this is not necessary.

Actually, we don't need the whole complex ownership transfer and assignment of ItemSyncs whenever an item is picked up. Whenever a player joins it can assign 2 ItemSync scripts to that player, one for the right and and one for the left hand. That means all of the collision resolution logic just needs to be handled once whenever somebody joins the world.
